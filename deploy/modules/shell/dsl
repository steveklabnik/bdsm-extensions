#!/usr/bin/env bash

hook()
{
  hook="$1"

  if (( ${hooks_flag:=1} == 1 ))
  then # Only process hooks if the flag is not explicitely set to 0.
    # System
    if file_is_nonempty "$shared_path/deploy/$hook"
    then
      ( source_files "$shared_path/deploy/$hook" )
    fi

    # System, Environment specific
    if variable_is_nonempty environment &&
       file_is_executable "$shared_path/deploy/#{$environment}/$hook"
    then
      ( source "$shared_path/deploy/#{$environment}/$hook" )
    fi

    # Project
    if path_exists "$shared_path/$project" &&
       file_is_executable "$shared_path/$project/config/deploy/$hook"
    then
      ( source "$shared_path/$project/config/deploy/$hook" )
    fi

    # Project, Environment specific
    if variable_is_nonempty environment &&
      file_is_executable "$shared_path/$project/config/deploy/$environment/$hook"
    then
      ( source "$shared_path/$project/config/deploy/$environment/$hook" )
    fi
  fi
}

update()
{
  if update_repository
  then
    if replace_current
    then
      return 0
    else
      return 1
    fi
  else
    return 1
  fi
}

update_repository()
{
  log "Updating local repository in $shared_path/$project."

  (
  enter "${shared_path}/${project}"

  case "$scm" in
    git)
      git checkout master -f -q

      # There should be *no* changes to the pristine repo.
      git reset --hard HEAD 2>/dev/null

      #current_branch=$(git branch | awk '/\* /{print $2}')
      log "Pulling updates from $remote"
      git fetch $remote

      log "Switching to branch $branch"

      current_branch=$(git symbolic-ref -q HEAD 2>/dev/null)

      if [[ "$current_branch" = "$branch" ]]
      then
        log "Already on branch '$branch'."

      elif ! git branch | awk "/$branch$/" >/dev/null 2>&1
      then
        git checkout -b $branch --track $remote/$branch 2>/dev/null

      elif ! git checkout $branch 2>/dev/null
      then
        error "Branch $remote/$branch not found. Skipping remainder of update."
        return 1
      fi

      git pull

      if file_exists ".gitmodules"
      then
        log "Updating submodules."
        git submodule init 2>/dev/null
        git submodule update
      fi

      if [[ -n "$revision" ]]
      then
        log "Checking out revision '$revision'."
        git checkout $revision >/dev/null 2>&1
      fi

      ;;

    hg)
      log "Pulling from remote"
      hg pull

      if [[ -n "$revision" ]]
      then
        # TODO: Find out if this is how it's done for hg ;)
        log "Checking out revision '$revision'."
        hg update $branch $revision
      else
        log "Updating branch '$branch'."
        hg update $branch
      fi
      ;;

    svn)
      # TODO: specific revision / branch handling
      log "Updating repository"
      svn update
      if [[ "$revision" -gt 0 ]]
      then
        log "Checking out revision $revision"
        svn checkout -r $revision
      fi
      ;;

    *)
      fail "No scm specified found (git,hg,svn)"
      ;;

  esac
  )
}

stage_current()
{
  log "Staging new release to $stage_path"

  # TODO: If rsync is available use it otherwise use cp -Rf
  rsync -ag --exclude=".${scm}/" "$shared_path/$project/" "$stage_path"

  ensure_paths_exist "$stage_path/public"
}

replace_current()
{
  if path_exists "$release_path"
  then
    log "Moving aside previous release."
    mv "$release_path" "$project_path/previous/$timestamp"
  fi

  log "Replacing $release_path from $stage_path"
  mv "$stage_path" "$release_path"
}

configure()
{
  if ! path_exists "$shared_path/config"
  then
    log "No shared config path found, skipping shared configuration."
    return 0
  fi

  local item config_item

  ensure_paths_exist "$stage_path/config"

  enter "${shared_path}/config"

  log "Setting up persistent config files:"
  for config_item in "$shared_path"/config/*
  do
    item=$(basename "$config_item")
    log "  - $item"
    link --force "$shared_path/config/$item" "$stage_path/config/$item"
  done
}

symlink()
{
  log "Setting up persistent directories:"

  for dir in tmp log pids files
  do
    log "  - $dir"
    remove_paths "${stage_path}/${dir}"
    link --force "${shared_path}/${dir}" to "${stage_path}/${dir}"
  done

  for dir in $(ls -A "$shared_path/public/")
  do
    log "  - public/$dir"
    remove_paths "${stage_path}/public/${dir}"
    link --force "${shared_path}/public/${dir}" to "${stage_path}/public/${dir}"
  done
}

cleanup()
{
  if path_exists "$project_path/previous"
  then
    log "Removing old releases: ${old_releases[@]}"
    enter "${project_path}/previous"

    if array_is_nonempty old_releases
    then
      remove_paths "${old_releases[@]}"
    fi
  fi
}

record()
{
  (
  enter "${shared_path}/$project"

  revision=$(git log --no-color -1 | awk '/commit/{print $2}')
  branch=$(git branch --no-color | awk '/^\* /{print $2}')

  echo "$revision" >> "$release_path/revision"
  echo "$branch"   >> "$release_path/branch"
  # TODO: What else could we record that would be useful?
  )
}

detect_scm()
{
  if [[ -z "${scm:-}" ]]
  then
    if [[ -d "$shared_path/$project/.git" ]]
    then
      scm="git"
    elif [[ -d "$shared_path/$project/.svn" ]]
    then
      scm="svn"
    elif [[ -d "$shared_path/$project/.hg" ]]
    then
      scm="hg"
    fi
  fi
}

deploy()
{
  # TODO:
  #
  #   * Crank up the verbosity on errors
  #
  # This will run any deploy hooks that are called
  #   (by hook file name)
  # Hooks are sourced into a subshell IF they are executable.
  # This means that users may disable hooks by changing their
  # execute bit.
  #
  detect_scm

  if ! command_exists rsync
  then
    error "The 'rsync' command was not found, please install rsync before using"\
      "deploy. (Note that there is an rsync bdsm extension, which you can install"\
      "viathe command as root: root# bdsm extend rsync && bdsm rsync install"
  fi

  # TODO: Call Rollback on errors when appropriate.

  hook "before_update_repository"
  update_repository
  hook "after_update_repository"

  hook "before_deploy"

  hook "before_stage"
  stage_current
  hook "after_stage"

  hook "before_configure"
  configure
  hook "after_configure"

  hook "before_symlink"
  symlink
  hook "after_symlink"

  hook "before_replace_current"
  replace_current
  hook "after_replace_current"

  hook "before_cleanup"
  cleanup
  hook "after_cleanup"

  hook "before_record"
  record
  hook "after_record"

  hook "after_deploy"

  log "Deploy started at $timestamp and completed at $(date +%m.%d.%YT%H:%M:%S)"
}

rollback()
{
  if directory_exists "$previous"
  then
    log "Discarding current release to $discard_path/$timestamp ..."
    mv "$release_path" "$discard_path/$timestamp"

    log "Rolling back to previous release $previous ..."
    mv "$previous" "${release_path%/}"

    log "Rollback complete."
  else
    log "No previous releases to rollback to."
  fi
}
